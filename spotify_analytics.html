<!doctype html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/6.5.0/d3.min.js"></script>
    <script src="https://d3js.org/d3-array.v2.min.js"></script>
    <script src="https://d3js.org/d3-scale.v3.min.js"></script>
    <script src="https://d3js.org/d3-dsv.v1.min.js"></script>
    <script src="https://d3js.org/d3-path.v2.min.js"></script>
    <script src="https://d3js.org/d3-fetch.v2.min.js"></script>

</head>
<style>
    body { background-color: white; -ms-overflow-style: none; scrollbar-width: none; font-family: sans-serif; margin:0; }
    ::-webkit-scrollbar { background: #bbb; height: 10px; }
    ::-webkit-scrollbar-thumb { background: #357DED; }

    .top-nav { background-color: #abb4cf; width: 100%; display: flex; flex-direction: row; position: fixed; justify-content: flex-end; z-index: 1; }
    svg { margin: 0; z-index: 0;}
    svg rect { stroke: #000; }
    svg text { fill:black; font: 2rem sans-serif; }
    svg domain, svg g.tick text{ fill: black; }
    /*svg rect:hover { fill: #B24C63; }*/
    svg .scree-bar { fill: #357DED; }
    svg .scree-bar:hover { fill: #B24C63; }
    svg .y-axis {text-anchor: right;}
    circle { opacity: 0.75;}
    circle:hover { opacity: 1;}

    .dropdown { background-color: #454955; color:#f3eff5; min-width: 200px; }
    .dropdown-content { display: none; flex-direction: column; position: absolute;
        color: #454955; background-color: #f3eff5; min-width: 200px; }
    .dropdown-header { padding: 10px; }
    .dropdown-option { width: 180px; padding: 10px;}
    .dropdown-option:hover { margin: 0; background-color: grey; width: 180px; padding: 10px; }
    .dropdown:hover .dropdown-content { display: flex;}
    .dropdown a { text-decoration: none; color:#454955; }
    text { background-color: white; }
    #info-modal { position:absolute; left: 0; top: 40px; border: 1px solid black; border-radius: 10px;
        padding: 20px; z-index: 100; background-color: rgba(255,255,255,1); color: rgba(0,0,0,1);
    }
    #info-modal table { display: none }
    #info-modal:hover { background-color: rgba(255,255,255,1); color: rgba(0,0,0,1); }
    #info-modal:hover table { display: block; }
    .svg-scatter-matrix .tick text { font-size: 10px; }
    .svg-parallel text.axis-label { font-size: 1rem; text-anchor: middle;}
    .svg-parallel text.min-y, .svg-parallel text.max-y { font-size: 1rem; text-anchor: end;}
    table, th, td { border: 1px solid black; }
    .scatter-show { display: none; }
    .legend-square { width: 1rem; height: 1rem; display:inline-block; }
    .show-parallel { display: block;  }
    polyline:hover {fill:"red"; stroke:"blue";}
    .tick text, text.data { font-size: 1rem; }
    .mds-option:hover { cursor: pointer; text-decoration: underline; }
    .parallel-axes text { font-size: 0.8rem ; font-weight: bold;}
</style>
<body>
    <title> Spotify Track Performances </title>
    <div class="top-nav">
        <div class="dropdown-header" style="font-style: bold"> Spotify Songs </div>
        <div class="dropdown">
            <div class="dropdown-header"> Analytic View </div>
            <div class="dropdown-content">
                <a class="dropdown-option" href="/spotify_data.html">Data View</a>
                <!-- <a class="dropdown-option" href="/spotify_analytics.html">Analytic View</a> -->
            </div>
        </div>
        <div class="dropdown-header" style="flex-grow: 1; font-style: bold"> </div>
        <div class="dropdown">
            <div class="dropdown-header">Change Graph</div>
            <div id="category-selector" class="dropdown-content">
            </div>
        </div>

        <div class="dropdown-header"> Data </div> 
        <div class="dropdown">
            <div class="dropdown-header"> Source </div>
            <div class="dropdown-content">
                <a class="dropdown-option" href="https://www.kaggle.com/edumucelli/spotifys-worldwide-daily-song-ranking">Song Ranking</a>
                <a class="dropdown-option" href="https://www.kaggle.com/mrmorj/dataset-of-songs-in-spotify?select=genres_v2.csv">Spotify Song Dataset 1</a>
                <a class="dropdown-option" href="https://www.kaggle.com/yamaerenay/spotify-dataset-19212020-160k-tracks?select=data.csv">Spotify Song Dataset 2</a>
            </div>
        </div>
    </div>
    <div id="info-modal" class="scatter-show">
        <div id="scatter-matrix-screen">
            <span style="cursor: pointer" class="to-scree" class="scatter-show"><< Return</span><br>
            <div class="scatter-show" id="dim-ind-container">
            <hr>
            Dimensionality Index: <span id="dim-ind"> </span><br>
            </div>
            <div class="scatter-show">
            <hr>
            Clusters: 
            <select name="cluster-count" id="cluster-count">
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
              <option value="8">8</option>
              <option value="9">9</option>
            </select>
            </div>
            <div class="scatter-show" id="legend">  
                <b>Legend</b><br>
                <div id="legend-options">
                </div>
            </div>
            <div class="scatter-show" id="dim-ind-table-container">
            <table id="dim-ind-table">
            </table>
            </div>
            <div class="show-parallel">
                <hr>
                Distance Metric:
                <select name="distance-metric" id="distance-metric">
                  <option value="l2">Euclidean</option>
                  <option value="l1">Manhattan</option>
                  <option value="correlation">Correlation</option>
                </select>
                <hr>
                <ol id="selection-order">
                </ol>
                <div id="clear-mds-select" class="mds-option"> Clear Selection</div>
                <div id="pcp-mds-select" class="mds-option" style="display:none"> View PCP</div>
            </div>
        </div>
    </div>
    <script>
        var colors = ["#006400","#00008b", "#b03060", "#ff4500", "#ffff00",
            "#deb887", "#00ff00", "#00ffff" ,"#ff00ff", "#6495ed"];
        var matrixDim = 4,
            matrixYOffset = 40,
            matrixWidth = window.innerWidth - 10,
            matrixHeight = window.innerHeight - matrixYOffset,
            legendWidth = 200,
            graphMargin = 25,
            graphWidth = (matrixWidth - legendWidth - matrixDim * 2 * graphMargin) / matrixDim,
            graphHeight = (matrixHeight - matrixDim * 2 * graphMargin) / matrixDim,
            screeMargin = 20,
            graphTransitionTime = 2500,
            axisMargin = 120;
        var selectionOrder = [];
        var datasets = {};

        var scaleX = null, scaleY = null;
        svg = d3.select("body")
            .append("svg")
            .attr("width", matrixWidth)
            .attr("height", matrixHeight)
            .attr("transform", `translate(0, ${matrixYOffset})`);

        var views = [];
        var cur_view = null;

        function toggleView(view) {
            let toggledOptions = document.getElementsByClassName("scatter-show");
            for (var i=0; i<toggledOptions.length; i++) {
                toggledOptions[i].style.display = view == ".svg-scree" ? "none" : "block";
            }
            for (var i=0; i < views.length; i++) {
                let curview = d3.select(views[i]);
                if (views[i] != view 
                    && curview != null 
                    && curview.attr("visibility") != "hidden") {
                    curview.attr("opacity", 1).transition().duration(graphTransitionTime).attr("opacity", 0)
                        .on("end", function(){ curview.attr("visibility", "hidden"); });
                }
            }
            if (views.indexOf(view) >= 0){
                d3.select(view)
                    .attr("visibility", "visible")
                    .attr("opacity", 0).transition().duration(graphTransitionTime).attr("opacity", 1);

            }
            if (view == ".svg-scatter-matrix") {
                // document.getElementById("dim-ind-table").style.display = "block";
                document.getElementById("dim-ind-container").style.display = "block";
                document.getElementById("dim-ind-table-container").style.display = "block";
            } else {
                // document.getElementById("dim-ind-table").style.display = "none";
                document.getElementById("dim-ind-container").style.display = "none";
                document.getElementById("dim-ind-table-container").style.display = "none";
            }
            document.getElementsByClassName("show-parallel")[0].style.display = "none";
        }

        function generateScale(data, key, range) {
            let keyMin = data.reduce((prev, cur)=> parseFloat(cur[key]) < prev ? parseFloat(cur[key]) : prev, parseFloat(data[0][key]));
            let keyMax = data.reduce((prev, cur)=> parseFloat(cur[key]) > prev ? parseFloat(cur[key]) : prev, parseFloat(data[0][key]));
            return d3.scaleLinear().domain([keyMin, keyMax]).range(range);
        }

        function generateScatterPlot(data, primary, secondary, container) {
            let scaleX = generateScale(data, primary, [0, graphWidth]);
            let scaleY = generateScale(data, secondary, [graphHeight, 0]);
            let axisX = d3.axisBottom(scaleX);
            let axisY = d3.axisLeft(scaleY);

            let rect = container.append("rect")
                .attr("width", graphWidth)
                .attr("height", graphHeight)
                .attr("fill", "white")
                .attr("x", container.attr("x"))
                .attr("y", container.attr("y"));
            
            if (primary == secondary) {
                let txt = container.append("text")
                    .attr("x", parseInt(container.attr("x")) + 0.5 * graphWidth)
                    .attr("y", parseInt(container.attr("y")) + 0.5 * graphHeight)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "2rem")
                    .text(primary)
            } else {
                let scatter = container.selectAll("circle")
                    .data(data)
                    .enter()
                    .append("circle")
                    .attr("cx", (d)=>parseFloat(container.attr("x")) + scaleX(parseFloat(d[primary])))
                    .attr("cy", (d)=>parseFloat(container.attr("y")) + scaleY(parseFloat(d[secondary])))
                    .attr("r", 2.5)
                    .attr("fill", function(d){
                        return colors[d[document.getElementById("cluster-count").value]]; 
                    });
                container.append("g")
                    .attr("transform", `translate(${parseFloat(container.attr("x"))}, ${parseFloat(container.attr("y")) + graphHeight})`)
                    .call(axisX);
                container.append("g")
                    .attr("transform", `translate(${parseFloat(container.attr("x"))}, ${parseFloat(container.attr("y"))})`)
                    .attr("font-size", 8)
                    .call(axisY)
            }
        }

        function legendOption(label, color) {
            let op = document.createElement("div");
            let box = document.createElement("div");
            box.classList.add("legend-square");
            box.style.backgroundColor = color;
            let boxlabel = document.createElement("span");
            boxlabel.textContent = label;
            op.appendChild(box);
            op.appendChild(boxlabel);
            document.getElementById("legend-options").appendChild(op);
        }

        function organizeScatterMatrix(data, keys) {
            views.push(".svg-scatter-matrix");
            cur_view = ".svg-scatter-matrix";

            let svg_scatter_matrix = svg.append("g").attr("class", "svg-scatter-matrix");
            for (var j=0; j<keys.length; j++) {
                for (var i=0; i<keys.length; i++) {
                    let cur = svg_scatter_matrix.append("g")
                        .attr("width", graphWidth)
                        .attr("height", graphHeight)
                        .attr("x", (graphWidth + 2 * graphMargin) * i + graphMargin + legendWidth)
                        .attr("y", (graphHeight + 2 * graphMargin) * j + graphMargin / 2);
                    generateScatterPlot(data, keys[i], keys[j], cur);
                }
            }
        }

        function parseNum(string, fixed) {
            if (isNaN(string)) {
                return string;
            }
            return parseFloat(string) == parseInt(string) ? parseInt(string) : parseFloat(parseFloat(string).toFixed(fixed));
        }

        function accumulateObjects(objArr) {
            var total = {}
            for (var i=0; i < objArr.length; i++) {
                for (key in objArr[i]) {
                    if (!(key in total)) {
                        total[key] = parseNum(objArr[i][key], 3) ** 2;
                    } else {
                        total[key] += parseNum(objArr[i][key], 3) ** 2;
                    }
                }
            }
            total["Dimension"] = "SSL"
            return total;
        }

        function scatterWithAttr(data, dim_ind) {
            let keys = [];
            dim_ind = parseInt(dim_ind["Dimension"]);
            for (var key in data[0]) {
                if (["Dimension", "Explained variance", "Explained variance ratio"].indexOf(key) == -1) {
                    keys.push([key, data.slice(0, dim_ind).reduce((prev, cur, i)=> i <= dim_ind ? prev + parseFloat(cur[key]) ** 2 : prev, 0)]);
                }
            }

            keys.sort((a,b)=>b[1] - a[1]);
            
            svg.select(".svg-scree")
                .attr("opacity", 1).transition().duration(graphTransitionTime).attr("opacity", 0)
                .on("end", function(){ d3.select(".svg-scree").attr("visibility", "hidden"); });;

            let vitalAttributes = keys.slice(0,4).map((x)=>x[0]);
            document.getElementById("dim-ind").textContent = dim_ind;
            d3.csv("public/spotify_numeric_norm.csv").then(function(data) {
                d3.select(".svg-scatter-matrix").remove();
                organizeScatterMatrix(data, vitalAttributes);
                toggleView(".svg-scatter-matrix");
                d3.select(".svg-scatter-matrix")
                    .attr("visibility", "visible")
                    .attr("opacity", 0).transition().duration(graphTransitionTime).attr("opacity", 1);
            }).then(function() {
                vitalAttributes.push("Dimension");
                if (d3.select("#dim-ind-table tr").empty()) {
                    let th = d3.select("#dim-ind-table")
                        .append("tr")
                        .selectAll("th")
                        .data(Object.keys(data[0]).filter((k)=>vitalAttributes.indexOf(k) >= 0))
                        .enter()
                        .append("th")
                        .text((d)=>d);

                    let tr = d3.select("#dim-ind-table")
                        .selectAll("tr")
                        .data(data.slice(0, dim_ind).concat([accumulateObjects(data.slice(0, dim_ind))]), d=>d)
                        .enter()
                        .append("tr")
                        .attr("class", "data-tr");

                    tr.selectAll("td")
                        .data((d)=>Object.keys(d).filter((k)=>vitalAttributes.indexOf(k) >= 0).map((k)=>[k, d[k]]))
                        .enter()
                        .append("td")
                        .text(function(d) { return parseNum(d[1],3); });
                } else {
                    d3.selectAll("#dim-ind-table th")
                        .data(Object.keys(data[0])
                        .filter((k)=>vitalAttributes.indexOf(k) >= 0))
                        .join().text((d)=>d);

                    d3.select("#dim-ind-table")
                        .selectAll("tr.data-tr")
                        .data(data.slice(0, dim_ind).concat([accumulateObjects(data.slice(0, dim_ind))]), d=>d)
                        .join("tr")
                        .attr("class", "data-tr");

                    d3.selectAll(".data-tr")
                        .selectAll("td")
                        .data(d=>Object.keys(d).filter((k)=>vitalAttributes.indexOf(k) >= 0).map((k)=>[k, d[k]]))
                        .join("td")
                        .text(d=>parseNum(d[1],3));
                }
            });
        }

        function generateBar(data, key, container, scaleX, scaleY, scaleYReversed, barWidth) {
            container.selectAll("rect").data(data)
                .enter().append("rect")
                .attr("class", "scree-bar")
                .attr("width", barWidth)
                .attr("height", (d)=>scaleY(parseFloat(d[key])))
                .attr("x", (d, i)=>graphMargin / 2 + scaleX(String(i+1)))
                .attr("y", (d)=>scaleYReversed(parseFloat(d[key]))).attr("fill","black")
                .on("click", (d,i)=> scatterWithAttr(data, i));
        }

        function generateLine(data, key, container, scaleX, scaleY, scaleYReversed, barWidth) {
            let cumulativeContribution = []
            for (var i=0; i<data.length; i++) {
                cumulativeContribution.push(i == 0 ? parseFloat(data[i][key]) : 
                    parseFloat(data[i][key]) + cumulativeContribution[cumulativeContribution.length - 1])
            }
            let cumulativeLine = d3.line()
                .x(function(d,i) { return scaleX(String(i+1)) + 0.5 * barWidth + graphMargin; })
                .y((d)=>scaleYReversed(d));

            container.append("path").datum(cumulativeContribution)
              .attr("d", cumulativeLine)
              .attr("stroke", "black")
              .attr("stroke-width", 5)
              .attr("fill-opacity", 0)
        }

        function generateScree(data, key) {
            // Generate scales
            let svg_scree = svg.append("g").attr("class", "svg-scree");
            views.push(".svg-scree");
            cur_view = ".svg-scree";
            var graphMargin = 10;
            let barWidth = (matrixWidth - 2 * axisMargin) / (data.length) - 2 * graphMargin;
            let labels = [];
            let locs = [];
            for (var i = 0; i < data.length; i++) {
                labels.push(String(i + 1));
                locs.push(axisMargin + (barWidth + 2 * graphMargin) * i + graphMargin);
            }
            let maxY = data.reduce((prev, cur)=> parseFloat(cur[key]) > prev ? parseFloat(cur[key]) : prev, parseFloat(data[0][key]));
            
            var scaleX = d3.scaleOrdinal().domain(labels).range(locs);
            var scaleY = d3.scaleLinear().domain([0,1]).range([0, matrixHeight - 2 * screeMargin - axisMargin]);
            var scaleYReversed = d3.scaleLinear().domain([0,1]).range([matrixHeight - 2 * screeMargin - axisMargin / 2, axisMargin / 2]);

            svg_scree.append("text")
                .attr("x", matrixWidth / 2)
                .attr("y", axisMargin / 2)
                .attr("text-anchor", "middle")
                .text("PCA Decomposition Explained Variance");
            svg_scree.append("text")
                .attr("x", matrixWidth / 2 - axisMargin)
                .attr("y", matrixHeight - 40)
                .text("PCA Component")
            svg_scree.append("text")
                .attr("transform", `rotate(${-90})`)
                .attr("y", 20)
                .attr("x", -matrixHeight / 2)
                .attr("dy", "1em")
                .attr("text-anchor", "middle")
                .text(key)
            
            // Generate axes
            let axisX = d3.axisBottom().scale(scaleX);
            svg_scree.append("g")
                .attr("transform", `translate(${0.5 * barWidth + graphMargin},${scaleYReversed(0)})`)
                .call(axisX)
            let axisY = d3.axisLeft().scale(scaleYReversed);
            svg_scree.append("g")
                .attr("transform", `translate(${axisMargin}, 0)`)
                .attr("class", "y-axis")
                .call(axisY)
            // Generate graph
            generateBar(data, key, svg_scree, scaleX, scaleY, scaleYReversed, barWidth);
            generateLine(data, key, svg_scree, scaleX, scaleY, scaleYReversed, barWidth);
        } 

        function cosine(v1, v2) {
            var total = 0;
            for (var key in v2){
                total += parseFloat(v1[key]) * parseFloat(v2[key])
            }
            return total;
        }

        function generateMDS(data, key_pts, vectors, chartname, title, x_axis, y_axis, showVectors) {
            if (views.indexOf(`.${chartname}`) >= 0) {
                return
            }

            let svg_mds = svg.append("g").attr("class", chartname);
            views.push("." + chartname);
            cur_view = `.${chartname}`

            var minX = Math.min.apply(Math, data.map((x)=>parseFloat(x['x_l1'])).concat(data.map((x)=>parseFloat(x['x_l2']))));
            var maxX = Math.max.apply(Math, data.map((x)=>parseFloat(x['x_l1'])).concat(data.map((x)=>parseFloat(x['x_l2']))));
            var minY = Math.min.apply(Math, data.map((x)=>parseFloat(x['y_l1'])).concat(data.map((x)=>parseFloat(x['y_l2']))));
            var maxY = Math.max.apply(Math, data.map((x)=>parseFloat(x['y_l1'])).concat(data.map((x)=>parseFloat(x['y_l2']))));

            scaleX = d3.scaleLinear().domain([minX, maxX]).range([legendWidth + axisMargin, matrixWidth])
            scaleY = d3.scaleLinear().domain([minY, maxY]).range([matrixHeight - axisMargin, axisMargin])
            var axisX = d3.axisBottom().scale(scaleX);
            var axisY = d3.axisLeft().scale(scaleY);

            svg_mds.append("g")
                .attr("transform", `translate(${0},${scaleY(minY)})`)
                .attr("class", "x-axis")
                .call(axisX);
            svg_mds.append("g")
                .attr("transform", `translate(${axisMargin + legendWidth}, ${0})`)
                .attr("class", "y-axis")
                .call(axisY);
            svg_mds.append("text")
                .attr("x", matrixWidth / 2 + axisMargin)
                .attr("y", axisMargin / 2)
                .attr("text-anchor", "middle")
                .text(title)
            svg_mds.append("text")
                .attr("x", matrixWidth / 2 + axisMargin)
                .attr("y", matrixHeight - axisMargin / 2)
                .text(x_axis)
            svg_mds.append("text")
                .attr("transform", `rotate(${-90})`)
                .attr("y", 20 + legendWidth)
                .attr("x", - matrixHeight / 2)
                .attr("dy", "1em")
                .attr("text-anchor", "middle")
                .text(y_axis)
            
            let circles_data = svg_mds.selectAll("circle.data").data(data)
                .enter().append("circle")
                .attr("cx", (d)=>scaleX(parseFloat(d["x_l2"])))
                .attr("cy", (d)=>scaleY(parseFloat(d["y_l2"])))
                .attr("r", 5)
                .attr("fill", (d)=>colors[d[document.getElementById("cluster-count").value]])
                .attr("class", "data")

            document.getElementById("distance-metric")
                .addEventListener("click", function(e){
                    // svg_mds.selectAll("text.data").exit().delete();
                    if (e.srcElement.value == "l2") {
                        scaleX = d3.scaleLinear().domain([minX, maxX]).range([legendWidth + axisMargin, matrixWidth - axisMargin])
                        scaleY = d3.scaleLinear().domain([minY, maxY]).range([matrixHeight - axisMargin, axisMargin])
                        svg_mds.selectAll("circle")
                            .data(data).join("circle")
                            .transition().duration(1200)
                            .attr("cx", (d)=>scaleX(parseFloat(d["x_l2"])))
                            .attr("cy", (d)=>scaleY(parseFloat(d["y_l2"])))
                            .attr("r", 5)
                            .attr("fill", (d)=>colors[d[document.getElementById("cluster-count").value]])
                            .attr("class", "data")
                    } else if (e.srcElement.value == "l1") {
                        scaleX = d3.scaleLinear().domain([minX, maxX]).range([legendWidth + axisMargin, matrixWidth - axisMargin])
                        scaleY = d3.scaleLinear().domain([minY, maxY]).range([matrixHeight - axisMargin, axisMargin])
                        svg_mds.selectAll("circle")
                            .data(data).join("circle")
                            .transition().duration(1200)
                            .attr("cx", (d)=>scaleX(parseFloat(d["x_l1"])))
                            .attr("cy", (d)=>scaleY(parseFloat(d["y_l1"])))
                            .attr("r", 5)
                            .attr("fill", (d)=>colors[d[document.getElementById("cluster-count").value]])
                            .attr("class", "data");
                    } else {
                        scaleX = d3.scaleLinear().domain([0, 1.0]).range([legendWidth + axisMargin, matrixWidth - axisMargin])
                        scaleY = d3.scaleLinear().domain([0, 1.0]).range([matrixHeight - axisMargin, axisMargin])
                        var attr_labels = svg_mds.selectAll("text.data")
                            .data(key_pts).enter().append("text")
                            .attr("fill", "black")
                            .attr("x", (d)=>scaleX(parseFloat(d["x"])))
                            .attr("y", (d)=> -15 + scaleY(parseFloat(d["y"])))
                            .attr("class", "data")
                            .attr("display", "none")
                            .text((d)=>d["labels"]);
                        let attr_circles = svg_mds.selectAll("circle")
                            .data(key_pts).join("circle")
                            .transition().duration(1200)
                            .attr("fill", "black")
                            .attr("cx", (d)=>scaleX(parseFloat(d["x"])))
                            .attr("cy", (d)=>scaleY(parseFloat(d["y"])))
                        svg_mds.selectAll("circle").on("click", function(e,d){
                            if (selectionOrder.indexOf(d) == -1) {
                                selectionOrder.push(d);
                                let li = document.createElement("li");
                                li.innerText = d.labels;
                                document.getElementById("selection-order").appendChild(li);
                                if (selectionOrder.length == key_pts.length) {
                                    document.getElementById("pcp-mds-select").style.display = "block";
                                }
                            }
                            d3.select(this).attr("fill", "red");
                        }).on("mouseover", function(e,d){
                            attr_labels._groups[0][key_pts.indexOf(d)].style.display = "block";
                        }).on("mouseout", function(e,d){
                            attr_labels._groups[0][key_pts.indexOf(d)].style.display = "none";
                        });
                    }
                    axisX.scale(scaleX)
                    axisY.scale(scaleY)
                    svg_mds.selectAll("g.x-axis").call(axisX);
                    svg_mds.selectAll("g.y-axis").call(axisY);
                });
        }

        function generateBiplot(data, vectors, chartname, title, x_axis, y_axis, showVectors) {

            if (views.indexOf(`.${chartname}`) >= 0) {                
                d3.select(`.${chartname}`).selectAll("circle")
                    .transition()
                    .duration(1200)
                    .attr("cx", function(d){ return axisMargin + scaleX(cosine(d, vectors[0]))})
                    .attr("cy", (d)=>axisMargin + scaleY(cosine(d, vectors[1])))
                return;
            }

            let svg_biplot = svg.append("g").attr("class", chartname);
            views.push("." + chartname);
            cur_view = `.${chartname}`

            let minX = data.reduce((prev, cur)=> cosine(cur, vectors[0]) < prev ? cosine(cur, vectors[0]) : prev, 0)
            let maxX = data.reduce((prev, cur)=> cosine(cur, vectors[0]) > prev ? cosine(cur, vectors[0]) : prev, 0)
            let minY = data.reduce((prev, cur)=> cosine(cur, vectors[1]) < prev ? cosine(cur, vectors[1]) : prev, 0)
            let maxY = data.reduce((prev, cur)=> cosine(cur, vectors[1]) > prev ? cosine(cur, vectors[1]) : prev, 0)

            let v0 = [], v1 = [];
            for (var i in vectors[0]) {
                v0.push(vectors[0][i]);
            }
            for (var i in vectors[1]) {
                v1.push(vectors[1][i]);
            }
            console.log(vectors[0]);
            for (var i=0; i<vectors.length && showVectors; i++) {
                let dim = Array(vectors.length).fill(0);
                dim[i] = 1;
                if (cosine(v0, dim) < minX) {
                    minX = cosine(v0, dim);
                } else if (cosine(v0, dim) > maxX) {
                    maxX = cosine(v0, dim);
                }
                if (cosine(v1, dim) < minY) {
                    minY = cosine(v1, dim);
                } else if (cosine(v1, dim) > maxY) {
                    maxY = cosine(v1, dim);
                }
            }

            scaleX = d3.scaleLinear().domain([minX, maxX]).range([legendWidth + axisMargin, matrixWidth - axisMargin])
            scaleY = d3.scaleLinear().domain([minY, maxY]).range([matrixHeight - 2 * axisMargin, 0])
            let axisX = d3.axisBottom().scale(scaleX);
            let axisY = d3.axisLeft().scale(scaleY);
            for (var i=0; i<vectors.length && showVectors; i++) {
                let dim = Array(vectors.length).fill(0);
                dim[i] = 1;
                let tmp = svg_biplot.append("path")
                  .attr("d", `M ${scaleX(0)} ${axisMargin + scaleY(0)} L ${scaleX(cosine(v0, dim))} ${axisMargin + scaleY(cosine(v1, dim))}`)
                  .attr("stroke", "black")
                  .attr("stroke-width", 2)
                  .attr("fill-opacity", 0)
                console.log(tmp);
            }

            svg_biplot.append("g")
                .attr("transform", `translate(${0},${scaleY(minY) + axisMargin})`)
                .call(axisX);
            svg_biplot.append("g")
                .attr("transform", `translate(${axisMargin + legendWidth}, ${axisMargin})`)
                .attr("class", "y-axis")
                .call(axisY);
            svg_biplot.append("text")
                .attr("x", matrixWidth / 2 + axisMargin)
                .attr("y", axisMargin / 2)
                .attr("text-anchor", "middle")
                .text(title)
            svg_biplot.append("text")
                .attr("x", matrixWidth / 2)
                .attr("y", matrixHeight - axisMargin / 2)
                .text(x_axis)
            svg_biplot.append("text")
                .attr("transform", `rotate(${-90})`)
                .attr("y", 20 + legendWidth)
                .attr("x", - matrixHeight / 2)
                .attr("dy", "1em")
                .attr("text-anchor", "middle")
                .text(y_axis)

            let circles = svg_biplot.selectAll("circle").data(data)
                .enter().append("circle")
                .attr("cx", (d)=>scaleX(cosine(d, vectors[0])))
                .attr("cy", (d)=>axisMargin + scaleY(cosine(d, vectors[1])))
                .attr("r", 5)
                .attr("fill", (d)=>colors[d[document.getElementById("cluster-count").value]]);
        }

        function generateParallelCoordinates(data, attributes) {
            let svg_parallel = svg.append("g").attr("class", "svg-parallel");
            views.push(".svg-parallel");
            cur_view = ".svg-parallel";

            let attribute_x = [];
            let attribute_range = [];
            let attribute_scales = [];
            let attribute_axes = [];
            let attribute_filters = [];
            for (var i=0; i < attributes.length; i++) {
                let attr = attributes[i];
                attribute_range.push([parseNum(data[0][attr]), parseNum(data[0][attr])]);
                for (d in data) {
                    let cur_range = attribute_range[attribute_range.length - 1];
                    cur_range[0] = Math.min(cur_range[0], parseNum(data[d][attr], 3));
                    cur_range[1] = Math.max(cur_range[1], parseNum(data[d][attr], 3));
                }
                attribute_scales.push(
                    d3.scaleLinear()
                        .domain(attribute_range[attribute_range.length - 1])
                        .range([axisMargin, matrixHeight - axisMargin])
                );
                attribute_x.push(legendWidth + i * (matrixWidth - 1 * axisMargin - legendWidth) / (attributes.length - 1));
            }

            var paths = [];
            for (datum of data) {            
                let path = [];
                for (ind in attributes) {
                    path.push([attribute_x[ind], attribute_scales[ind](datum[attributes[ind]])]);
                }
                paths.push(svg_parallel.append("path")
                    .datum(datum)
                    .attr("d", function(d,i) {
                        let path = attributes
                            .map((attr, ind)=>([attribute_x[ind], attribute_scales[ind](d[attr])]));
                        return d3.line().x((p)=>p[0]).y((p)=>p[1])(path);
                    })
                    .attr("stroke", (d)=>colors[datum[document.getElementById("cluster-count").value]])
                    .attr("stroke-width", 0.75)
                    .attr("fill-opacity", 0));
            }

            var mouseDownFilter = null,
                mouseUpFilter = null;

            function refreshPathFilters(){
                paths.forEach(function(path){
                    path.attr("opacity", 1.00);
                    attribute_filters.forEach(function(filter, i){
                        if (filter != null && 
                                (parseFloat(path._groups[0][0].__data__[attributes[i]]) < filter[0] ||
                                parseFloat(path._groups[0][0].__data__[attributes[i]]) > filter[1])) {
                            path.attr("opacity", 0.01);
                        }
                    });
                });
            }

            let attribute_filter_rects = {}
            attribute_scales.forEach(function(scale, i) {
                let axis = d3.axisRight(scale);
                attribute_axes.push(svg_parallel.append("g")
                    .attr("class", "parallel-axes")
                    .attr("transform", `translate(${attribute_x[i]},${0})`)
                    .attr("cursor", "pointer")
                    .call(axis));
                attribute_filters.push(null);

                d3.drag().on("start", function(event, d) {
                        mouseDownFilter = event.y;
                    })
                    .on("end", function(event, d) {
                        mouseUpFilter = event.y
                        let attribute = attributes[i];
                        if (attribute_filters[i] == null) {
                            let filter_rect = svg_parallel.append("rect")
                                .attr("x", attribute_x[i] - 10)
                                .attr("y", Math.min(mouseUpFilter, mouseDownFilter))
                                .attr("height", Math.abs(mouseDownFilter - mouseUpFilter))
                                .attr("width", 20)
                                .attr("fill", `rgba(200,200,200,0.5)`)
                                .attr("class", "parallel-filter")
                                .on("click", function(d){
                                    attribute_filters[attributes.indexOf(attribute)] = null;
                                    d3.select(this).remove();
                                    refreshPathFilters();
                            });

                            let upperBound = attribute_scales[i].invert(Math.max(mouseUpFilter, mouseDownFilter));
                            let lowerBound = attribute_scales[i].invert(Math.min(mouseUpFilter, mouseDownFilter));
                            attribute_filters[i] = [lowerBound, upperBound, filter_rect];
                            refreshPathFilters();
                        }
                    })(attribute_axes[attribute_axes.length - 1]);
            });
                
            svg_parallel.selectAll("text.axis-label")
                .data(attribute_x)
                .enter().append("text")
                .attr("x", (d)=>d)
                .attr("y", matrixHeight - axisMargin + 20)
                .attr("class", "axis-label")
                .text((d, i)=>attributes[i]);
            
            function triangle(cx, cy, r, reverse) {
                let flat_side = reverse ? cx - r / Math.sqrt(2) : cx + r / Math.sqrt(2);
                let point = reverse ? cx + r / 2 : cx - r / 2;
                return `${flat_side} ${cy - r / Math.sqrt(2)}, ${flat_side} ${cy + r / Math.sqrt(2)}, ${point} ${cy}`
            }

            function swap(cx, cy, r) {
                return `${cx - r / 2} ${cy + r / 4}, ${cx + r / 2} ${cy + r / 4}, ${cx + r / 2} ${cy + r / 2}, ${cx + r} ${cy}, ${cx + r / 2} ${cy - r / 2}, ${cx + r / 2} ${cy - r / 4}, ${cx - r / 2} ${cy - r / 4}, ${cx - r / 2} ${cy - r / 2}, ${cx - r} ${cy}, ${cx - r / 2} ${cy + r / 2}, ${cx - r / 2} ${cy + r / 4}`
            }

            svg_parallel.append("text")
                .attr("x", matrixWidth / 2 + axisMargin)
                .attr("y", axisMargin / 2)
                .attr("text-anchor", "middle")
                .text("Parallel Coordinate Plot");

            svg_parallel.selectAll("polyline")
                .data(attribute_x.slice(0,-1))
                .enter().append("polyline")
                .attr("points", (d)=>swap(d + (matrixWidth - 2 * axisMargin) / (attributes.length - 1) / 2, matrixHeight - axisMargin + 40, 20))
                .on("click", function(e, d) {
                    let ind = attribute_x.indexOf(d);
                    let tmp_att = attributes[ind];
                    attributes[ind] = attributes[ind + 1];
                    attributes[ind + 1] = tmp_att;
                    let tmp_scale = attribute_scales[ind];
                    attribute_scales[ind] = attribute_scales[ind + 1];
                    attribute_scales[ind + 1] = tmp_scale;
                    let tmp_range = attribute_range[ind];
                    attribute_range[ind] = attribute_range[ind + 1];
                    attribute_range[ind + 1] = tmp_range;
                    let tmp_filter = attribute_filters[ind];
                    attribute_filters[ind] = attribute_filters[ind + 1];
                    attribute_filters[ind + 1] = tmp_filter;
                    
                    // let tmp_filter_rect = attribute_filter_rects[ind];
                    // attribute_filter_rects[ind] = attribute_filter_rects[ind + 1];
                    // attribute_filter_rects[ind + 1] = tmp_filter_rect;

                    if (attribute_filters[ind] && attribute_filters[ind][2]) {
                        attribute_filters[ind][2].attr("x", attribute_x[ind]);
                    }
                    if (attribute_filters[ind+1] && attribute_filters[ind+1][2]) {
                        attribute_filters[ind+1][2].attr("x", attribute_x[ind+1]);
                    }
                    // d3.selectAll(".parallel-filter").remove();
                    // for (var i=0; i < attribute_filters.length; i++) {
                    //     attribute_filters[i] = null;
                    // }
                    // refreshPathFilters();

                    for (svg_path of paths) {
                        svg_path.attr("d", function(d) {
                            let path = attributes
                                .map((attr, ind)=>([attribute_x[ind], attribute_scales[ind](d[attr])]));
                            return d3.line().x((p)=>p[0]).y((p)=>p[1])(path);
                        });
                    }
                    attribute_axes.forEach((axisG, i)=>axisG.call(d3.axisRight(attribute_scales[i])));

                    svg_parallel.selectAll("text.axis-label")   
                        .text((d, i)=>attributes[i]);
                    svg.selectAll("text.min-y").text((d, i)=>attribute_range[i][0]);
                    svg.selectAll("text.max-y").text((d, i)=>attribute_range[i][1]);
                });
        }

        function option(menu, optionName) {
            let col = document.createElement("span");
            let link = document.createElement("a");
            link.innerText = optionName;
            col.appendChild(link);
            menu.appendChild(col);
            col.classList.add("dropdown-option");
            return col;
        }

        let op1 = option(document.getElementById("category-selector"), "Scree");
        op1.addEventListener("click", function(){
            toggleView(".svg-scree");
        });
        let op2 = option(document.getElementById("category-selector"), "Biplot");
        op2.addEventListener("click", function(){
            if (views.indexOf(".svg-biplot") == -1) {
                Promise.all([d3.csv("public/spotify_numeric_norm.csv"), d3.csv("public/pca_values.csv")]).then(function(data){
                    generateBiplot(data[0], data[1], "svg-biplot", "Two Most Influential PCA Dimensions", "PCA1", "PCA2", true);
                    d3.select(".svg-biplot").attr("opacity", 0).attr("visibility", "hidden");
                    toggleView(".svg-biplot");
                });
            } else {
                toggleView(".svg-biplot");
            }
        });
        //
        let op3 = option(document.getElementById("category-selector"), "MDS");
        op3.addEventListener("click", function(){
            if (views.indexOf(".svg-mds") == -1) {
                Promise.all([d3.csv("public/mds.csv"), d3.csv("public/correlation_mds.csv")]).then(function(data){
                    generateMDS(data[0], data[1], [{'x_l2': 0, 'y_l2': 1}, {'x_l2': 1, 'y_l2': 0}], "svg-mds", "Multidimensional Scaling", "x", "y");
                    d3.select(".svg-mds").attr("opacity", 0).attr("visibility", "hidden");
                    toggleView(".svg-mds");
                    document.getElementsByClassName("show-parallel")[0].style.display = "block";
                });
            } else {
                generateMDS(null, null, [{'x_l2': 0, 'y_l2': 1}, {'x_l2': 1, 'y_l2': 0}], "svg-mds", "Multidimensional Scaling", "x", "y");
                toggleView(".svg-mds");
                document.getElementsByClassName("show-parallel")[0].style.display = "block";
            }
        });
        let op4 = option(document.getElementById("category-selector"), "Parallel");
        op4.addEventListener("click", function(){
            if (views.indexOf(".svg-parallel") == -1) {
                d3.csv("public/spotify_numeric.csv").then(function(data){
                    generateParallelCoordinates(data.slice(), Object.keys(data[0]).filter((key)=>isNaN(key)));
                    d3.select(".svg-parallel").attr("opacity", 0).attr("visibility", "hidden");
                    toggleView(".svg-parallel");
                });
            } else {
                toggleView(".svg-parallel");
            }
        });

        for (var i=0; i < parseInt(document.getElementById("cluster-count").value); i++) {
            legendOption(" Cluster " + i, colors[i]);
        }
        document.getElementById("cluster-count").addEventListener("change", function(e){
            svg.selectAll("circle").attr("fill", d=>colors[d[e.srcElement.value]]);
            document.getElementById("legend-options").innerHTML = "";
            for (var i=0; i < parseInt(e.srcElement.value); i++) {
                legendOption(" Cluster " + i, colors[i]);
            }
            d3.select(".svg-parallel")
                .selectAll("path")
                .attr("stroke", (d)=>colors[d[e.srcElement.value]]);
        });
        document.getElementById("clear-mds-select").addEventListener("click", function(e) {
            document.getElementById("selection-order").innerHTML = "";
            document.getElementById("pcp-mds-select").style.display = "none";
            selectionOrder = [];
            d3.select(".svg-mds").selectAll("circle").attr("fill", "black");
        });
        document.getElementById("pcp-mds-select").addEventListener("click", function(e) {   
            if (views.indexOf(".svg-parallel") == -1) {
                d3.csv("public/spotify_numeric.csv").then(function(data){
                    generateParallelCoordinates(data.slice(), selectionOrder.map((x)=>x["labels"]));
                    d3.select(".svg-parallel").attr("opacity", 0).attr("visibility", "hidden");
                    toggleView(".svg-parallel");
                });
            } else {
                toggleView(".svg-parallel");
            }
        });
        d3.selectAll(".to-scree").on("click", function(){
            if (d3.select(".svg-scree")) {
                toggleView(".svg-scree");
            } else {
                d3.csv("public/pca_reduction.csv").then(function(data){
                    generateScree(datasets["pca_reduction.csv"], "Explained variance ratio");
                });
            }
        });

        d3.csv("public/pca_reduction.csv").then(function(data){
            datasets["pca_reduction.csv"] = data;
            generateScree(data, "Explained variance ratio");
        });
    </script>
</body>

</html>
